package debop4s.data.mybatis.mapping

import debop4s.data.mybatis.config
import org.slf4j.LoggerFactory


/**
 * Abstract SQL statement mapping.
 * @author sunghyouk.bae@gmail.com 15. 3. 19.
 */
trait Statement {

  protected val log = LoggerFactory.getLogger(getClass)

  /**
   * Fully qualified identifier of the statement.
   * Autogenerated by the configuration space.
   */
  var fqi: FQI = null

  /**
   * Any one of STATEMENT, PREPARED or CALLABLE
   * This causes MyBatis to use Statement, PreparedStatement or CallableStatement respectively.
   * Default: PREPARED
   */
  var statementType: StatementType = StatementType.PREPARED

  /**
   * This sets the maximum time the driver will wait for the database to return from a request,
   * before throwing an timeout exception.
   * Default: is unset (driver dependent)
   */
  var timeout = -1
  /**
   * Setting this to true will cause the cache to be flushed whenever this statement is called.
   * Default: false for select statements.
   */
  var flushCache = true

  /**
   * Vendor ID
   */
  var databaseId: String = _

  /** Scripting driver */
  var languageDriver = config.DefaultScriptingDriver

  /**
   * Dynamic SQL definition, an xml node with root &lt;xsql&gt;
   * {{{
   *   def xsql = "SELECT * FROM mytable WHERE id = #{{id}}"
   * }}}
   *
   * Or using dynamic tags:
   * {{{
   *   def xsql =
   * <xsql>
   * SELECT *
   * FROM mytable
   * <where>
   * <if test="name != null">
   * name like #{{name}}
   * </if
   * </where>
   * </xsql>
   * }}}
   * @return
   */
  def xsql: XSQL

  /**
   * Returns the Class of the input parameter.
   * @return class of input parameter
   */
  def parameterTypeClass: Class[_]

  def execute[R](command: => R): R = fqi match {
    case null =>
      throw new config.ConfigurationException(s"Unknown Statement ${this.getClass.getName}")
    case _ =>
      command
  }

}
